---
title: "QB2023_Team_Project"
author: "Erica Nadolski, Z620: Quantitative Biodiversity, Indiana University"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: pdf_document
geometry: margin = 2.54cm
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##### Data input and setup 
# Site by species matrix
```{r}
library(tidyverse)
library(dplyr)

# read in dataset 
Ponds.rel <- as.matrix(read.csv("/Users/ericanadolski/GitHub/team2/Ponds.rel.csv", row.names=1))

# subsetting total (DNA) and active (cDNA) libraries for each site
keep_DNA <- c("BC001-DNA","BC002-DNA","BC003-DNA","BC004-DNA","BC005-DNA","BC010-DNA","BC015-DNA","BC016-DNA","BC018-DNA","BC020-DNA","BC048-DNA","BC049-DNA","BC051-DNA","BC105-DNA","BC108-DNA","BC262-DNA","BCL01-DNA","BCL03-DNA","HNF132-DNA","HNF133-DNA","HNF134-DNA","HNF144-DNA","HNF168-DNA","HNF185-DNA","HNF187-DNA","HNF216-DNA","HNF217-DNA","HNF221-DNA","HNF224-DNA","HNF225-DNA","HNF229-DNA","HNF242-DNA","HNF250-DNA","HNF267-DNA","HNF269-DNA","YSF004-DNA","YSF117-DNA","YSF295-DNA","YSF296-DNA","YSF298-DNA","YSF300-DNA","YSF44-DNA","YSF45-DNA","YSF46-DNA","YSF47-DNA","YSF65-DNA","YSF66-DNA","YSF67-DNA","YSF69-DNA","YSF70-DNA","YSF71-DNA","YSF74-DNA") 
# "HNF189-DNA","HNF190-DNA","HNF191-DNA","HNF236-DNA","HNF237-DNA","HNF279-DNA")

keep_cDNA <- c("BC001-cDNA","BC002-cDNA","BC003-cDNA","BC004-cDNA","BC005-cDNA","BC010-cDNA","BC015-cDNA","BC016-cDNA","BC018-cDNA","BC020-cDNA","BC048-cDNA","BC049-cDNA","BC051-cDNA","BC105-cDNA","BC108-cDNA","BC262-cDNA","BCL01-cDNA","BCL03-cDNA","HNF132-cDNA","HNF133-cDNA","HNF134-cDNA","HNF144-cDNA","HNF168-cDNA","HNF185-cDNA","HNF187-cDNA","HNF189-cDNA","HNF190-cDNA","HNF191-cDNA","HNF216-cDNA","HNF217-cDNA","HNF221-cDNA","HNF224-cDNA","HNF225-cDNA","HNF229-cDNA","HNF236-cDNA","HNF237-cDNA","HNF242-cDNA","HNF250-cDNA","HNF267-cDNA","HNF269-cDNA","HNF279-cDNA","YSF004-cDNA","YSF117-cDNA","YSF295-cDNA","YSF296-cDNA","YSF298-cDNA","YSF300-cDNA","YSF44-cDNA","YSF45-cDNA","YSF46-cDNA","YSF47-cDNA","YSF65-cDNA","YSF66-cDNA","YSF67-cDNA","YSF69-cDNA","YSF70-cDNA","YSF71-cDNA","YSF74-cDNA")

# Extract rows from matrix
total <- Ponds.rel[rownames(Ponds.rel) %in% keep_DNA, ]     
active <- Ponds.rel[rownames(Ponds.rel) %in% keep_cDNA, ]  

# use these shortened names
row.names(total) <- c("B001","B002","B003","B004","B005","B010","B015","B016","B018","B020","B048","B049","B051","B105","B108","B262","BL01","BL03","H132","H133","H134","H144","H168","H185","H187","H189","H190","H191","H216","H217","H221","H224","H225","H229","H236","H237","H242","H250","H267","H269","H279","Y004","Y117","Y295","Y296","Y298","Y300","Y44","Y45","Y46","Y47","Y65","Y66","Y67","Y69","Y70","Y71","Y74")
 # "HNF189","HNF190","HNF191","HNF236","HNF237","HNF279")

row.names(active) <- c("BC001-cDNA","BC002-cDNA","BC003-cDNA","BC004-cDNA","BC005-cDNA","BC010-cDNA","BC015-cDNA","BC016-cDNA","BC018-cDNA","BC020-cDNA","BC048-cDNA","BC049-cDNA","BC051-cDNA","BC105-cDNA","BC108-cDNA","BC262-cDNA","BCL01-cDNA","BCL03-cDNA","HNF132-cDNA","HNF133-cDNA","HNF134-cDNA","HNF144-cDNA","HNF168-cDNA","HNF185-cDNA","HNF187-cDNA","HNF189-cDNA","HNF190-cDNA","HNF191-cDNA","HNF216-cDNA","HNF217-cDNA","HNF221-cDNA","HNF224-cDNA","HNF225-cDNA","HNF229-cDNA","HNF236-cDNA","HNF237-cDNA","HNF242-cDNA","HNF250-cDNA","HNF267-cDNA","HNF269-cDNA","HNF279-cDNA","YSF004-cDNA","YSF117-cDNA","YSF295-cDNA","YSF296-cDNA","YSF298-cDNA","YSF300-cDNA","YSF44-cDNA","YSF45-cDNA","YSF46-cDNA","YSF47-cDNA","YSF65-cDNA","YSF66-cDNA","YSF67-cDNA","YSF69-cDNA","YSF70-cDNA","YSF71-cDNA","YSF74-cDNA")
```


### code to subset sequencing libraries by -DNA suffix
```{r, echo=FALSE}
# select -DNA libraries using grep
comm <- comm[grep("*-DNA", rownames(comm)), ]

# rename sites by performing replacement of all matches with gsub
rownames(comm) <- gsub("\\-DNA", "", rownames(comm))
rownames(comm) <- gsub("_", "", rownames(comm))
```

# Pond Environmental data
```{r}
Ponds.env <- as.matrix(read.csv("/Users/ericanadolski/GitHub/team2/Ponds.env.csv", row.names=1)) 

# number of sites
nrow(Ponds.env) 
# number of measurements
ncol(Ponds.env) 
# env data missing for "HNF279", 189, 190, 191, 236, 237

# get data to numeric type
env <- apply(Ponds.env[,1:20], 2, function(x) as.numeric(as.character(x))) 

# apply row names
row.names(env) <- c("BC001","BC002","BC003","BC004","BC005","BC010","BC015","BC016","BC018","BC020","BC048","BC049","BC051","BC105","BC108","BC262","BCL01","BCL03","HNF132","HNF133","HNF134","HNF144","HNF168","HNF185","HNF187","HNF189","HNF190","HNF191","HNF216","HNF217","HNF221","HNF224","HNF225","HNF229","HNF236","HNF237","HNF242","HNF250","HNF267","HNF269","HNF279","YSF004","YSF117","YSF295","YSF296","YSF298","YSF300","YSF44","YSF45","YSF46","YSF47","YSF65","YSF66","YSF67","YSF69","YSF70","YSF71","YSF74")

# remove sites with NA; tried na.action=na.exclude(), na.roughfix but didn't work
env <- env[1:53,-1] 
env <- env[-34,]
```


### Scatter plot of some environmental variables just to look at variation
```{r}
env <- as.data.frame(Ponds.env)

env <- env %>% mutate_at(c("lat","long","Elevation","Diameter","Depth","Cal_Volume","ORP","Temp","SpC","DO","TDS","Salinity","pH","Color","chla","DOC","DON","canopy","TP"), as.numeric)

str(env)

diam <- env[1:56,"Diameter"]
max(diam)
min(diam)
mean(diam)

depth <- env[1:56,"Depth"]
max(depth)
min(depth)
mean(depth)

p <- ggplot(env, aes(x=Diameter, y=Depth, label=X))
p + geom_point(aes(colour = factor(Location))) + geom_text(hjust=0, vjust=0, size=2) + scale_x_continuous(n.breaks = 10)
```


## PCA of Environmental Variables just to visualize variation

```{r pressure, echo=FALSE}
env.pca = prcomp(env)

```

> ***Dataset Note***: We are using a Lennon lab dataset of microbial DNA and cDNA extracted from local ponds. There are 58 pond sites, and 34059 species (OTUs) across all the sites. There is high variance in abundance and evenness across all of the sites; based on exploratory rank abundance curves, there is high abundance of a few OTUs and a long tail of low-abundance OTUs.
```

### Alpha Diversity 
```{r}
### Rank abundance plot of site 1 
ponds.rac <- as.numeric(RAC(Ponds97[1,]))
length(ponds.rac)
max(ponds.rac)
min(ponds.rac)
plot.new()
pond.ranks <- as.vector(seq(1, length(ponds.rac)))
plot(pond.ranks, log(ponds.rac), type="p", axes=F,
     xlab="Rank in abundance", ylab="Abundance",
     las=1, cex.lab=1.4, cex.axis=1.25);
box();
axis(side=1, labels=T, cex.axis=1.25);
axis(side=2, las=1, cex.axis=1.25,
     labels= c(1,10,100,1000,100000), at=log(c(1,10,100,1000,10000)))
```

## Beta Diversity - Visualization

```{r}
# Bray Curtis resemblance matrix
total.db <- vegdist(total, method="bray")

# Heatmap 
order.p <- rev(attr(total.db, "Labels"))

levelplot(as.matrix(total.db)[,order.p], aspect="iso", col.regions=inferno,
          xlab="Pond Site", ylab= "Pond Site", scales=list(cex=0.5), 
          main= "Bray-Curtis Distance")

# Wards cluster analysis
total.ward <- hclust(total.db, method= "ward.D2")

par(mar = c(1, 5, 2, 2) + 0.1)
plot(total.ward, main="Indiana Pond Bacteria: Ward's Clustering", ylab= "Squared Bray-Curtis Distance")

# Principal Component Analysis
total.pcoa <- cmdscale(total.db, eig=TRUE, k=3)

exvar1 <- round(total.pcoa$eig[1] / sum(total.pcoa$eig), 3) * 100
exvar2 <- round(total.pcoa$eig[2] / sum(total.pcoa$eig), 3) * 100
exvar3 <- round(total.pcoa$eig[3] / sum(total.pcoa$eig), 3) * 100
total.sum.eig <- sum(exvar1, exvar2, exvar3)

# PCoA Plot PC1 x PC2 colored by state park
par(mar = c(2, 2, 2, 2) + 3)
plot(total.pcoa$points[ ,1], total.pcoa$points[ ,2],
     #xlim = c(-0.55, -0.3),
     #ylim = c(-0.03, 0.01),
     xlab= paste("PCoA 1 (", exvar1, "%)", sep = ""),
     ylab= paste("PCoA 2 (", exvar2, "%)", sep = ""),
     pch = 16, cex = 2.0, type = "n", cex.lab = 1.5,
     cex.axis=1.2, axes=FALSE);
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1);
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1);
abline(h = 0, v = 0, lty = 3);
box(lwd = 2);                                        
points(total.pcoa$points[1:18,1], total.pcoa$points[1:18,2],
       pch = 20, cex = 2, bg = "blue", col = "blue"); # BC
points(total.pcoa$points[19:41,1], total.pcoa$points[19:41,2],
       pch = 20, cex = 2, bg = "red", col = "red"); # H
points(total.pcoa$points[42:58,1], total.pcoa$points[42:58,2],
       pch = 20, cex = 2, bg = "purple", col = "purple");# YW
legend(x="topleft",,legend=c("Brown County", "Hoosier Natl. Forest", "Yellowood"),
       fill=c("blue", "red","purple"))

```


## Beta Diversity - Hypothesis Testing 

### i.  Mantel Test
1. create distance matrices for pond communities and environmental factors, and
2. use a Mantel test to test the hypothesis that pond assemblages are correlated with pond environmental variables.

```{r}
# define matrices
OTU.dist <- vegdist(total, method="bray")
pond.env.dist <- vegdist(env, method="euclid")

# mantel test
mantel(OTU.dist,pond.env.dist)
```

### Constrained Ordination - distance based redundancy analysis dbRDA
1. create an environmental matrix of the pond data using forward and reverse selection of variables
2. conduct a redundancy analysis on the bacterial assemblages
3. use a permutation test to determine the significance of the constrained analysis,
4. use a permutation test to determine the correlation of each environmental factor on the constrained axes,
5. calculate the explained variation on the first and second constrained axes,
6. plot the constrained ordination results including labeled points for each site, and
7. add vectors that demonstrate the influence of each environmental factor the constrained ordination.   

```{r}
# Constrained Ordination
pond.dbrda <- dbrda(total ~ ., as.data.frame(env)) #perform dbRDA
ordiplot(pond.dbrda)

# first model only intercept
pond.dbrda.mod0 <- dbrda(total ~ 1, as.data.frame(env)) 
ordiplot(pond.dbrda.mod0) # no vectors constrained here, so its a simple MDS (PCoA)

# now model with all explanatory variables
pond.dbrda.mod1 <- dbrda(total ~ ., as.data.frame(env))

# now iterate through all combos of explanatory variables, return model with lowest AIC
# pond.dbrda <- ordiR2step(pond.dbrda.mod0,pond.dbrda.mod1, permutations = how(nperm = 200))
# couldnt get ordiR2step to work, error that upper scope cannot be reached
pond.dbrda <- ordistep(pond.dbrda.mod0,pond.dbrda.mod1, permutations = how(nperm = 200))

# look at model that was selected
pond.dbrda$call
pond.dbrda$anova
ordiplot(pond.dbrda)

# permutation tests to evaluate significance
permutest(pond.dbrda, permutations=999)
envfit(pond.dbrda, env[,c(2,5,13,18)], perm=999)

#calculate explained variation
pond.dbrda.explainvar1 <- round(pond.dbrda$CCA$eig[1] / sum(c(pond.dbrda$CCA$eig, pond.dbrda$CA$eig)), 3) *100
pond.dbrda.explainvar2 <- round(pond.dbrda$CCA$eig[2] / sum(c(pond.dbrda$CCA$eig, pond.dbrda$CA$eig)), 3) *100

# now plot selected model, define plot parameters
pond.vectors <- scores(pond.dbrda,display="bp")
plot(scores(pond.dbrda, display="wa"), xlab=paste("dbRDA 1 (",pond.dbrda.explainvar1,"%)", sep=""), 
     ylab=paste("dbRDA 2 (", pond.dbrda.explainvar2, "%)", sep=""),
     pch=16, cex=2.0, type="n", cex.lab=1.5, cex.axis=1.2, axes=FALSE);
axis(side=1, labels=T, lwd.ticks=2, cex.axis=1.2,las=1);
axis(side=2, labels=T, lwd.ticks=2, cex.axis=1.2,las=1);
abline(h=0,v=0,lty=3);
box(lwd=2);
points(scores(pond.dbrda,display="wa"), pch=19,cex=3,bg="gray",col="gray");
text(scores(pond.dbrda,display="wa"),labels=row.names(scores(pond.dbrda,display="wa")));
arrows(0,0,pond.vectors[,1], pond.vectors[,2], lwd=2, lty=1, length=0.2, col="red");
text(pond.vectors[,1], pond.vectors[,2], pos=3,labels=row.names(pond.vectors));
axis(side=3, lwd.ticks=2, cex.axis=1.2,las=1, col="red", lwd=2.2,
     at=pretty(range(pond.vectors[,1]))*2, labels=pretty(range(pond.vectors[,1])));
axis(side=4, lwd.ticks=2, cex.axis=1.2,las=1, col="red", lwd=2.2,
     at=pretty(range(pond.vectors[,2]))*2, labels=pretty(range(pond.vectors[,2])))
scores(pond.dbrda)
# code to modify to try and color plots by state park again
points(total.pcoa$points[1:18,1], total.pcoa$points[1:18,2],
       pch = 20, cex = 2, bg = "blue", col = "blue"); # BC
points(total.pcoa$points[19:41,1], total.pcoa$points[19:41,2],
       pch = 20, cex = 2, bg = "red", col = "red"); # H
points(total.pcoa$points[42:58,1], total.pcoa$points[42:58,2],
       pch = 20, cex = 2, bg = "purple", col = "purple");# YW
legend(x="topright",,legend=c("Brown County", "Hoosier Natl. Forest", "Yellowood"),
       fill=c("blue", "red","purple"))


env2 <- env[,c(2,5,13,18)]

## plot output is odd because pond.vectors are values < 1 so they look tiny in comparison to site dbRDA values which are ~100s... is this an error in the code?

## try RDA or NMDS instead of dbRDA, investigate HNF sites as 

## note for Erica to think about -- try to add spec scores to an ordination plot with a cut off only showing the most correlated OTUs?
```

> ***Synthesis Answer***: According to the Mantel test, 7% of the variation in pond bacterial communities can be explained by association with the ponds' corresponding environmental variables. This is much lower than what was found with the Doubs river data, but the bacterial OTUs are much more diverse than the fish species in the Doubs. The constrained ordination via dbRDA indicated that the variable "chla" was associated with much of the variation in pond data.

### Constrained Ordination - canonical correspondence analysis CCA
1. create an environmental matrix of the pond data using forward and reverse selection of variables
2. conduct a redundancy analysis on the bacterial assemblages
3. use a permutation test to determine the significance of the constrained analysis,
4. use a permutation test to determine the correlation of each environmental factor on the constrained axes,
5. calculate the explained variation on the first and second constrained axes,
6. plot the constrained ordination results including labeled points for each site, and
7. add vectors that demonstrate the influence of each environmental factor the constrained ordination.   

```{r}
# define environmental matrix 
str(env) 

# conduct CCA
pond.cca <- cca(total ~ env)

# permuatation tests to evaluate significance
anova(pond.cca, by= "axis")
ccafit <- envfit(pond.cca, env, perm=999)

#calculate explained variation
cca.explainvar1 <- round(pond.cca$CCA$eig[1] / sum(c(pond.cca$CCA$eig, pond.cca$CA$eig)), 3) *100
cca.explainvar2 <- round(pond.cca$CCA$eig[2] / sum(c(pond.cca$CCA$eig, pond.cca$CA$eig)), 3) *100

# now plot selected model, define plot parameters
pond.vectors <- scores(pond.dbrda,display="bp")
plot(scores(pond.dbrda, display="wa"), xlab=paste("dbRDA 1 (",pond.dbrda.explainvar1,"%)", sep=""), 
     ylab=paste("dbRDA 2 (", pond.dbrda.explainvar2, "%)", sep=""),
     pch=16, cex=2.0, type="n", cex.lab=1.5, cex.axis=1.2, axes=FALSE);
axis(side=1, labels=T, lwd.ticks=2, cex.axis=1.2,las=1);
axis(side=2, labels=T, lwd.ticks=2, cex.axis=1.2,las=1);
abline(h=0,v=0,lty=3);
box(lwd=2);
points(scores(pond.dbrda,display="wa"), pch=19,cex=3,bg="gray",col="gray");
text(scores(pond.dbrda,display="wa"),labels=row.names(scores(pond.dbrda,display="wa")));
arrows(0,0,pond.vectors[,1], pond.vectors[,2], lwd=2, lty=1, length=0.2, col="red");
text(pond.vectors[,1], pond.vectors[,2], pos=3,labels=row.names(pond.vectors));
axis(side=3, lwd.ticks=2, cex.axis=1.2,las=1, col="red", lwd=2.2,
     at=pretty(range(pond.vectors[,1]))*2, labels=pretty(range(pond.vectors[,1])));
axis(side=4, lwd.ticks=2, cex.axis=1.2,las=1, col="red", lwd=2.2,
     at=pretty(range(pond.vectors[,2]))*2, labels=pretty(range(pond.vectors[,2])))
scores(pond.dbrda)
# code to modify to try and color plots by state park again
points(total.pcoa$points[1:18,1], total.pcoa$points[1:18,2],
       pch = 20, cex = 2, bg = "blue", col = "blue"); # BC
points(total.pcoa$points[19:41,1], total.pcoa$points[19:41,2],
       pch = 20, cex = 2, bg = "red", col = "red"); # H
points(total.pcoa$points[42:58,1], total.pcoa$points[42:58,2],
       pch = 20, cex = 2, bg = "purple", col = "purple");# YW
legend(x="topright",,legend=c("Brown County", "Hoosier Natl. Forest", "Yellowood"),
       fill=c("blue", "red","purple"))
```

## 7) Phylogenetic Tree

Obtain reference sequences for taxa in your study, for microorganisms, ribosomal gene (i.e., 16S rRNA).
1. Download sequences and create a properly formatted fasta file.
2. Align the sequences and confirm that you have a good alignment. 
3. Choose a substitution model and make a tree of your choice. 
4. Based on the decisions above and the output, does your tree jibe with what is known about the evolutionary history of your organisms? If not, why? Is there anything you could do differently that would improve your tree, especially with regard to future analyses done by your team?

```{r}
# set up packages
if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install("msa")

library(msa)
library(Biostrings)

# import taxonomy info for OTUs
taxa <- as.matrix(read.csv("/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/8.PhyloTraits/40taxa.csv", col.names= c("Otu","abundance","phylum","class","order","family","genus"), header=FALSE))

# data wrangling to get Otu names 
#taxa[,"genus"]
#taxa[,"family"]

# import fasta with outgroup
bac <- readDNAStringSet("/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/8.PhyloTraits/40bac.fasta", format="fasta")

# align sequences using default MUSCLE parameters
# read.aln <- msaMuscle(bac)

# convert alignment to DNAbin object {ape}
bac.DNAbin <- as.DNAbin(bac)

# visualize alignment {ape}
par(mar = c(4, 10, 4, 2))
image.DNAbin(bac.DNAbin, cex.lab=0.5)

# distance
bac.F84.outgroup <- match("Methanosarcina", bac.F84.tree$tip.label)
bac.F84.rooted <- root(bac.F84.tree, bac.F84.outgroup, resolve.root=TRUE)
# plot F84 neighbor joining tree
par(mar= c(1,1,2,1)+0.1)
plot.phylo(bac.F84.rooted, main="Pond Bacteria Neighbor Joining Tree", "phylogram", use.edge.length = FALSE, direction="right", cex=0.6, label.offset=1);
add.scale.bar(cex=0.7)

```

> ***Synthesis Answer***:  For this week, we decided it would be easiest to work with a subset of the ~35000 OTUs from the pond dataset, so we took a subset of the 40 OTUs with the highest overall read counts across the pond samples (coincidentally this metric was how the OTUs were named in the original project so we have a list of OTU 01-40). Our tree does fit with the known evolutionary relationships of the bacteria, we have the tips labeled by OTU with taxonomic information that we added up to the family level, and OTUs of the same families and genera are clustering together in our tree which confirms the accuracy of our tree compared to known relationships.


## Phylogenetics & Communities
1. load the environmental data for the Brown County ponds (*20130801_PondDataMod.csv*),  
2. load the site-by-species matrix using the `read.otu()` function,  
3. subset the data to include only DNA-based identifications of bacteria,  
4. rename the sites by removing extra characters,  
5. remove unnecessary OTUs in the site-by-species, and   
6. load the taxonomic data using the `read.tax()` function from the source-code file.

```{r}
env <- read.table("/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/9.PhyloCom/data/20130801_PondDataMod.csv",sep=",",header=TRUE)
env <- na.omit(env)

# site by species
comm <- read.otu(shared = "/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/9.PhyloCom/data/INPonds.final.rdp.shared", cutoff="1")

# select DNA using grep
comm <- comm[grep("*-DNA", rownames(comm)), ]

# perform replacement of all matches with gsub
rownames(comm) <- gsub("\\-DNA", "", rownames(comm))
rownames(comm) <- gsub("_", "", rownames(comm))

# remove sites not in env dataset
comm <- comm[rownames(comm) %in% env$Sample_ID, ]

# remove zero-abundance OTUs from data set
comm <- comm[ , colSums(comm) > 0]

# import taxonomy
tax <- read.tax(taxonomy = "/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/9.PhyloCom/data/INPonds.final.rdp.1.cons.taxonomy")
```

1. load the FASTA alignment for the bacterial operational taxonomic units (OTUs),
2. rename the OTUs by removing everything before the tab (\\t) and after the bar (|),  
3. import the *Methanosarcina* outgroup FASTA file,  
4. convert both FASTA files into the DNAbin format and combine using `rbind()`,
5. visualize the sequence alignment,  
6. using the alignment (with outgroup), pick a DNA substitution model, and create a phylogenetic distance matrix,  
7. using the distance matrix above, make a neighbor joining tree,  
8. remove any tips (OTUs) that are not in the community data set,  
9. plot the rooted tree.

```{r}
# import alignment file
ponds.cons <- read.alignment(file = "/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/9.PhyloCom/data/INPonds.final.rdp.1.rep.fasta", format="fasta")

# rename OTUs in fasta
ponds.cons$nam <- gsub("\\|.*$", "", gsub("^.*?\t", "", ponds.cons$nam))

# import outgroup
outgroup <- read.alignment(file="/Users/ericanadolski/GitHub/QB2023_Nadolski/2.Worksheets/9.PhyloCom/data/methanosarcina.fasta", format="fasta")

#convert alignment files to DNAbin and combine
DNAbin <- rbind(as.DNAbin(outgroup),as.DNAbin(ponds.cons))

#visualize alignment
image.DNAbin(DNAbin, show.labels=T, cex.lab=0.05, las=1)

# make distance matrix {ape}
seq.dist.jc <- dist.dna(DNAbin, model="JC", pairwise.deletion=FALSE)

# make neighbor joining tree file {ape}
phy.all <- bionj(seq.dist.jc)


# drop tips of zero occurrence OTUs {ape}
phy <- drop.tip(phy.all, phy.all$tip.label[!phy.all$tip.label %in% c(colnames(comm), "Methanosarcina")])
# ID outgroup
outgroup <- match("Methanosarcina", phy$tip.label)
# root tree
phy <- root(phy2,"Methanosarcina",resolve.root = TRUE)
#plot rooted tree {ape}
par(mar = c(1, 1, 2, 1) + 0.1)
plot.phylo(phy, main = "Neighbor Joining Tree", "phylogram",
      show.tip.label =TRUE, use.edge.length = FALSE,
      direction = "right", cex = 0.6, label.offset = 1)

```
